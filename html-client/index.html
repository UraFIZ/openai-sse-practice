<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SSE Streaming (HTML Client)</title>
    <style>
      :root {
        --bg: #0e1116;
        --panel: #151a22;
        --text: #e6edf3;
        --muted: #9aa4b2;
        --accent: #22c55e;
        --danger: #ef4444;
        --border: #243041;
      }
      body {
        margin: 0;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        background: radial-gradient(1200px 600px at 10% -10%, #1b2330 0%, transparent 60%), var(--bg);
        color: var(--text);
      }
      .wrap {
        max-width: 820px;
        margin: 40px auto;
        padding: 24px;
      }
      h1 {
        font-size: 28px;
        letter-spacing: 0.5px;
        margin: 0 0 16px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      textarea {
        width: 100%;
        min-height: 120px;
        background: #0b0f15;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px;
        font-size: 14px;
        resize: vertical;
        outline: none;
      }
      .row {
        display: flex;
        gap: 10px;
        margin-top: 12px;
      }
      button {
        border: 0;
        border-radius: 10px;
        padding: 10px 14px;
        font-size: 14px;
        cursor: pointer;
      }
      .send {
        background: var(--accent);
        color: #0a0f14;
        flex: 1;
        font-weight: 700;
      }
      .stop {
        background: var(--danger);
        color: #fff;
        min-width: 120px;
      }
      .meta {
        display: flex;
        gap: 20px;
        margin-top: 14px;
        color: var(--muted);
        font-size: 12px;
      }
      .output {
        margin-top: 18px;
        padding: 16px;
        border-radius: 12px;
        background: #0b0f15;
        border: 1px solid var(--border);
        white-space: pre-wrap;
        line-height: 1.6;
        min-height: 120px;
      }
      .cursor {
        display: inline-block;
        width: 8px;
        height: 16px;
        background: var(--text);
        margin-left: 4px;
        vertical-align: middle;
        animation: blink 1s step-end infinite;
      }
      @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>HTML SSE Client</h1>
      <div class="panel">
        <textarea id="prompt" placeholder="Ask for a long response to see streaming in action..."></textarea>
        <div class="row">
          <button class="send" id="sendBtn">Send</button>
          <button class="stop" id="stopBtn" disabled>Stop</button>
        </div>
        <div class="meta">
          <div>TTFT: <span id="ttft">-</span></div>
          <div>Total: <span id="total">-</span></div>
        </div>
        <div class="output" id="output"></div>
      </div>
    </div>

    <script>
      const promptEl = document.getElementById('prompt');
      const sendBtn = document.getElementById('sendBtn');
      const stopBtn = document.getElementById('stopBtn');
      const outputEl = document.getElementById('output');
      const ttftEl = document.getElementById('ttft');
      const totalEl = document.getElementById('total');

      let abortController = null;
      let startTime = 0;
      let firstToken = true;
      let wordQueue = [];
      let pumpTimer = null;
      let cursorEl = null;
      let streamDone = false;

      const startCursor = () => {
        if (!cursorEl) {
          cursorEl = document.createElement('span');
          cursorEl.className = 'cursor';
        }
        outputEl.appendChild(cursorEl);
      };

      const stopCursor = () => {
        if (cursorEl && cursorEl.parentNode) {
          cursorEl.parentNode.removeChild(cursorEl);
        }
      };

      const appendText = (text) => {
        if (cursorEl && cursorEl.parentNode === outputEl) {
          outputEl.insertBefore(document.createTextNode(text), cursorEl);
        } else {
          outputEl.appendChild(document.createTextNode(text));
        }
      };

      const startWordPump = () => {
        if (pumpTimer) return;
        pumpTimer = setInterval(() => {
          if (wordQueue.length === 0) {
            if (streamDone) {
              stopWordPump();
            }
            return;
          }
          const next = wordQueue.shift();
          appendText(next);
        }, 25);
      };

      const stopWordPump = () => {
        if (pumpTimer) {
          clearInterval(pumpTimer);
          pumpTimer = null;
        }
      };

      const enqueueWords = (text) => {
        const parts = text.split(/(\s+)/);
        for (const part of parts) {
          if (part.length > 0) wordQueue.push(part);
        }
      };

      const setLoading = (isLoading) => {
        sendBtn.disabled = isLoading;
        stopBtn.disabled = !isLoading;
      };

      const resetUi = () => {
        outputEl.textContent = '';
        ttftEl.textContent = '-';
        totalEl.textContent = '-';
        wordQueue = [];
        firstToken = true;
        streamDone = false;
      };

      const handleStop = () => {
        if (abortController) abortController.abort();
        setLoading(false);
        stopCursor();
        stopWordPump();
      };

      stopBtn.addEventListener('click', handleStop);

      const API_URL = 'http://localhost:5001/api/chat';

      sendBtn.addEventListener('click', async () => {
        const prompt = promptEl.value.trim();
        if (!prompt) return;

        resetUi();
        setLoading(true);
        startCursor();
        startTime = Date.now();

        abortController = new AbortController();

        try {
          const res = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt }),
            signal: abortController.signal,
          });
         

          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          if (!res.body) throw new Error('ReadableStream not supported in this browser');

          const reader = res.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';

          startWordPump();
          const { done, value } = reader.read();

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            buffer = buffer.replace(/\r\n/g, '\n');
            const events = buffer.split('\n\n');
            buffer = events.pop() ?? '';

            for (const event of events) {
              const lines = event.split('\n');
              const dataLines = lines.filter((l) => l.startsWith('data:'));
              if (dataLines.length === 0) continue;
              const dataStr = dataLines.map((l) => l.slice(5).trim()).join('\n');
              if (dataStr === '[DONE]') {
                totalEl.textContent = ((Date.now() - startTime) / 1000).toFixed(2) + 's';
                streamDone = true;
                continue;
              }

              try {
                const payload = JSON.parse(dataStr);
                if (payload && payload.text) {
                  if (firstToken) {
                    ttftEl.textContent = ((Date.now() - startTime) / 1000).toFixed(2) + 's';
                    firstToken = false;
                  }
                  enqueueWords(payload.text);
                }
              } catch {
                // Ignore malformed JSON chunk
              }
            }
          }
          streamDone = true;
        } catch (err) {
          if (err && err.name === 'AbortError') {
            enqueueWords('\n\n[Generation stopped by user]');
          } else {
            enqueueWords('\n\n[Error: Connection interrupted]');
          }
          streamDone = true;
        } finally {
          setLoading(false);
          stopCursor();
          abortController = null;
        }
      });
    </script>
  </body>
</html>
